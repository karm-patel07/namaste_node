app.js


require("dotenv").config();
const express = require("express");
const connectDB = require("./config/database");
const cookieParser = require("cookie-parser");
const cors = require("cors");
const { userAuth } = require("./middleware/auth");
const { authRouter } = require("./routes/authRouter");
const { profileRouter } = require("./routes/profileRouter");
const userRouter = require("./routes/userRouter");

const { requestRouter } = require("./routes/requestRouter");
const User = require("./models/User");
const app = express();
app.use(cors());
app.use(express.json());
app.use(cookieParser()); // ✅ REQUIRED for reading token from cookies
const port = 3000;
connectDB()
  .then(() => {
    console.log("database connection successfully ");
    app.use("/", authRouter);
    app.use("/", profileRouter);
    app.use("/Api", requestRouter);

    app.use("/", userRouter);

    app.listen(port, () => {
      console.log(`Your server started on port ${port}`);
      // console.log("JWT_SECRET:", process.env.JWT_SECRET);
    });
  })
  .catch(() => {
    console.error("not connect to database");
  });


--------------------------------------------------------------------------

database.js

const mongoose = require("mongoose");

const connectDB = async () => {
  try {
    await mongoose.connect(
      "mongodb+srv://badshahvirus:mahakal%402004%40@namaste.pdv9blg.mongodb.net/devTinder",
    );
    console.log("MongoDB connected successfully ✅");
  } catch (err) {
    console.error("MongoDB connection error ❌:", err.message);
    throw err;
  }
};

module.exports = connectDB;
--------------------------------------------------------------------------
auth.js

const jwt = require("jsonwebtoken");
const User = require("../models/User");

const userAuth = async (req, res, next) => {
  try {
    const token = req.cookies?.token;

    if (!token) {
      return res.status(401).json({ message: "Authentication failed" });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    const user = await User.findById(decoded._id);
    if (!user) {
      return res.status(401).json({ message: "User not found" });
    }

    req.user = user;
    return next(); // ✅ SAFE
  } catch (err) {
    return res.status(401).json({ error: err.message });
  }
};

module.exports = { userAuth };
--------------------------------------------------------------------------
connectionRequest.js

const mongoose = require("mongoose");

const connectionRequestSchema = new mongoose.Schema(
  {
    fromUserId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    toUserId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    status: {
      type: String,
      required: true,
      enum: {
        values: ["ignore", "interested", "accepted", "rejected"],
        message: `{VALUE} is not a correct status type`,
      },
    },
  },
  {
    timestamps: true,
  }
);

// index for faster queries
connectionRequestSchema.index({ fromUserId: 1, toUserId: 1 });

// validation: cannot send request to self
// connectionRequestSchema.pre("save", function (next) {
//   if (this.fromUserId.equals(this.toUserId)) {
//     return next(new Error("Cannot send connection request to yourself"));
//   }
//   next();
// });

module.exports = mongoose.model("connectionRequest", connectionRequestSchema);

--------------------------------------------------------------------------
User.js

const mongoose = require("mongoose");
const { isLowercase } = require("validator");
const userSchema = mongoose.Schema(
  {
    firstName: {
      type: String,
      require: true,
      minlength: 4,
      maxlength: 30,
    },
    lasttName: {
      type: String,
    },
    emailId: {
      type: String,
      require: true,
      unique: true,
      Lowercase: true,
      trim: true,
    },
    password: {
      type: String,
      require: true,
    },
    age: {
      type: Number,
      require: true,
    },
    gender: {
      type: String,
      validate(value) {
        if (!["male", "female", "other"].includes(value)) {
          throw new error("gender data is not valid");
        }
      },
    },
    skill: {
      type: [String],
    },
    about: {
      type: String,
      default: "this is default value of about",
    },
  },
  {
    Timestamp: "true",
  }
);
const User = mongoose.model("User", userSchema);
module.exports = User;
--------------------------------------------------------------------------
authRouter.js

const express = require("express");
const authRouter = express.Router();
const bcrypt = require("bcrypt");
const { validationsignUpData } = require("../utilis/validation");
const User = require("../models/User");
const jwt = require("jsonwebtoken");

// ===== ROUTES =====

authRouter.post("/signup", async (req, res) => {
  try {
    validationsignUpData(req);

    const { firstName, lastName, emailId, password, skill, age } = req.body;
    const passwordHash = await bcrypt.hash(password, 10);

    const user = new User({
      firstName,
      lastName,
      emailId,
      password: passwordHash,
      skill,
      age,
    });

    const savedUser = await user.save();

    res.status(201).json({
      message: "User created successfully",
      user: savedUser,
    });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

authRouter.post("/login", async (req, res) => {
  try {
    const { emailId, password } = req.body;
    const user = await User.findOne({ emailId });

    if (!user) {
      throw new Error("invalid credentials");
    }

    const ispassword = await bcrypt.compare(password, user.password);
    if (ispassword) {
      const token = jwt.sign({ _id: user._id }, process.env.JWT_SECRET, {
        expiresIn: "7d",
      });
      res.cookie("token", token, {
        expires: new Date(Date.now() + 8 * 3600000),
      });
      res.send("login successfully");
    } else {
      throw new Error("invalid credentials");
    }
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

authRouter.post("/logout", async (req, res) => {
  res.cookie("token", null, { expire: new Date(Date.now()) });
  res.send("logout succesfully");
});

module.exports = { authRouter };
--------------------------------------------------------------------------

profileRouter.js

const express = require("express");
const { userAuth } = require("../middleware/auth");
const { validate } = require("../utilis/validate");
const profileRouter = express.Router();

profileRouter.get("/profile/view", userAuth, async (req, res) => {
  try {
    const user = req.user;
    res.send(req.user);
  } catch (error) {
    res.status(400).send("something went to wrong");
  }
});
profileRouter.patch("/profile/edit", userAuth, async (req, res) => {
  try {
    if (!validate(req)) {
      throw new Error("Invalid edit request");
    }

    const loggedInUser = req.user;

    // Body ma avela  fields update karo
    Object.keys(req.body).forEach((key) => {
      loggedInUser[key] = req.body[key];
    });

    // only save once 
    await loggedInUser.save();

    res.send(`${loggedInUser.firstName}, your profile updated successfully`);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

module.exports = {
  profileRouter,
};

--------------------------------------------------------------------------
requestRouter.js

const express = require("express");
const requestRouter = express.Router();

// ✅ Correct destructuring for middleware
const { userAuth } = require("../middleware/auth");

// ✅ Correct model import, use Capital C & R
const ConnectionRequest = require("../models/connectionRequest");

// ---------------- SEND REQUEST ----------------
requestRouter.post(
  "/request/send/:status/:toUserId",
  userAuth,
  async (req, res) => {
    try {
      const fromUserId = req.user._id;
      const { status, toUserId } = req.params;

      if (!["interested", "ignored"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const connectionRequest = new ConnectionRequest({
        fromUserId,
        toUserId,
        status,
      });

      const data = await connectionRequest.save();

      return res.json({
        message: "Request sent successfully",
        data,
      });
    } catch (err) {
      return res.status(500).json({ error: err.message });
    }
  },
);

// ---------------- ACCEPT / REJECT ----------------
requestRouter.post(
  "/request/review/:status/:requestId",
  userAuth,
  async (req, res) => {
    try {
      const { status, requestId } = req.params;

      if (!["accepted", "rejected"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const request = await ConnectionRequest.findByIdAndUpdate(
        requestId,
        { status },
        { new: true },
      );

      return res.json({
        message: `Request ${status}`,
        request,
      });
    } catch (err) {
      return res.status(500).json({ error: err.message });
    }
  },
);

module.exports = { requestRouter };
--------------------------------------------------------------------------
userRouter.js

const express = require("express");
const { userAuth } = require("../middleware/auth");
const ConnectionRequest = require("../models/connectionRequest");
const { set } = require("mongoose");
const User = require("../models/User");
const userRouter = express.Router();

userRouter.get("/user/request/received", userAuth, async (req, res) => {
  try {
    const loggedInUser = req.user;

    const connectionRequest = await ConnectionRequest.find({
      toUserId: loggedInUser._id,
      status: "interested",
    }).populate("fromUserId", "firstName");

    res.json({
      message: "data fetched successfully",
      data: connectionRequest,
    });
  } catch (err) {
    res.status(400).send("ERROR " + err.message);
  }
});
userRouter.get("/user/connection", userAuth, async (req, res) => {
  try {
    const loggedInUser = req.user;
    const connectionRequest = await ConnectionRequest.find({
      $or: [
        { toUserId: loggedInUser, status: "accepted" },
        { fromUserId: loggedInUser._id, status: "accepted" },
      ],
    })
      .populate("fromUserId", ["firstName"])
      .populate("toUserId", ["firstName"]);
    const data = connectionRequest.map((row) => {
      if (row.fromUserId._id.toString() === loggedInUser._id.toString()) {
        return row.toUserId;
      }
      return row.fromUserId;
    });
    res.json({ data });
  } catch (err) {
    res.status(400).send("ERROR:" + err.message);
  }
});
userRouter.get("/feed", userAuth, async (req, res) => {
  try {
    const loggedInUser = req.user;
    const page = parseInt(req.query.page) || 1;
    let limit = parseInt(req.query.limit) || 10;
    limit = limit > 50 ? 50 : limit;
    const skip = (page - 1) * limit;

    // ✅ fetch all connections of logged-in user
    const connectionRequests = await ConnectionRequest.find({
      $or: [{ fromUserId: loggedInUser._id }, { toUserId: loggedInUser._id }],
    }).select("fromUserId toUserId");

    // ✅ track users to hide from feed
    const hideUserFromFeed = new Set();
    connectionRequests.forEach((req) => {
      hideUserFromFeed.add(req.fromUserId.toString());
      hideUserFromFeed.add(req.toUserId.toString());
    });

    // ✅ fetch users NOT connected and NOT self
    const users = await User.find({
      $and: [
        { _id: { $nin: Array.from(hideUserFromFeed) } },
        { _id: { $ne: loggedInUser._id } },
      ],
    })
      .select("firstName lastName email") // user info to show
      .skip(skip)
      .limit(limit);

    res.json({ data: users });
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
});

module.exports = userRouter;
--------------------------------------------------------------------------
validate.js

const validate = (req) => {
  const allowedEditField = [
    "firstName",
    "lastName",
    "emailId",
    "photoUrl",
    "gender",
    "age",
    "about",
    "skill",
  ];
  const isEditAllowed = Object.keys(req.body).every((fields) =>
    allowedEditField.includes(fields)
  );
  return isEditAllowed;
};
module.exports = { validate };


--------------------------------------------------------------------------
validation.js

const validator = require("validator");

const validationsignUpData = (req) => {
  const { firstName, lastName, emailId, password } = req.body;

  if (!firstName || !lastName || !emailId || !password) {
    throw new Error("All fields are required");
  }

  if (!validator.isStrongPassword(password)) {
    throw new Error("Password not a strong");
  }

  if (!validator.isEmail(emailId)) {
    throw new Error("email Id is not proper mail format");
  }
};

module.exports = { validationsignUpData };
